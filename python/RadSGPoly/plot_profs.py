"""
generates plots for RadSGPoly models (beta = 2 dust opacity) using data generated by shoot2.py.

plots generated can be turned on and off with `plotit` list where the plots are

0-quantities vs. radius.  better with only ~50 models, but a step parameter can be set to skip models
1- T vs. P, pretty boring and different models overlap even more than usual
2- properties at RCB, better with many models (500 used)
3- Luminosity evolution (vs M and Pcb)
"""

plotit = [0,0,0,1]
id = "mc5a10_500"

getdat = 0
savefig = 1
from utils.userpath import userpath
figfolder = userpath + "/figs/ModelAtmospheres/RadSelfGravPoly/Hill2/"

if getdat:
    from utils.constants import Me, Re, G, barP, sigma
    from RadSGPoly import shoot2 as s2
    datfolder = s2.datfolder
    file = id + ".npz"
    params, arr = s2.parammodelsload(file)
    natm = arr.shape[0]
    mco ,  delad = params.mco , params.delad
    Matm = arr.M - mco
    profs = s2.profiles(ngrid = 5000, file = file)#high resolution needed to get smooth behavior of RCB to nearest
                                                  #gridpoint.  interpolation would take care of this need.

    #compute del
       #del_act = profs.delrad.clip(max = params.delad) #this works just to get Del, but we also want info on where the RCB is
    del_act = profs.delrad
    conv_indices = del_act > params.delad
    del_act[conv_indices] = params.delad
    
    rcb_cols = conv_indices.argmax(axis = 1) #column indices where RCB transition occurs
                                             #works bc True > False
    rcb_inds = [range(natm),rcb_cols]
    Mconv = profs.m[rcb_inds]-mco
    Mrad = profs.m[:, 0] - profs.m[rcb_inds]
    RBc = G * mco / params.R / params.To
    RB = np.empty(natm)
    for i in range(natm):
        RB[i] = s2.rBondi(profs.m[i,:] , profs.r[i,:], params)
    
if plotit[0]:
    close(1)
    f , (ax1,ax2,ax3) = plt.subplots(3,figsize = (5,9),sharex = True, num = 1)   

    step = 1
    for i in range(natm-1,-1,-step):
    #for i in range(0,natm,step):
        fi = float(i)/(natm -1)
        ax1.loglog(profs.r[i , :]/Re , (profs.m[i , :]- mco)/Me , '', c = cm.rainbow(fi))
        ax2.loglog(profs.r[i , :]/Re, del_act[i , :] , '', c = cm.rainbow(fi))
        ax3.loglog(profs.r[i , :]/Re, profs.TK[i , :] , '', c = cm.rainbow(fi))

    ax3.set_xlabel(r'$r \; [R_\oplus]$')    
    ax1.set_ylabel(r'$m_\mathrm{atm}\; [M_\oplus]$')
    ax2.set_ylabel(r'$\nabla$')
    ax3.set_ylabel(r'$T\;[\mathrm{K}]$')
    #ax2.invert_xaxis()
    ax1.set_ylim(ymin = 1e-5)
    ax2.set_xlim(2, 2e4)
    ax3.set_ylim(30,1.5e4)
    ax2.set_ylim(ymax = 0.5)

    plt.draw()
    plt.tight_layout()
    f.subplots_adjust(hspace=0)
    plt.draw()

    if savefig:
        plt.savefig(figfolder+'r_profs_'+id+'.pdf')

if plotit[1]:
    close(2)
    f , ax = plt.subplots(1,figsize = (5,4),sharex = True, num = 2)
    for i in range(natm-1,-1,-step):
    #for i in range(0,natm,step):
        fi = float(i)/(natm -1)
        ax.loglog(profs.P[i , :]/barP, profs.TK[i , :] , '', c = cm.rainbow(fi))

    ax.invert_xaxis()
    ax.set_ylim(30,1.5e4)
    ax.set_ylabel(r'$T\;[\mathrm{K}]$')
    ax.set_xlabel(r'$P\;[\mathrm{bar}]$')
    plt.draw()
    plt.tight_layout()
    #f.subplots_adjust(hspace=0)
    plt.draw()

    if savefig:
        plt.savefig(figfolder+'TP_'+id+'.pdf')

if plotit[2]:
    #this NSG prediction for TCB only works for beta = 2
    delinf , del_o = 0.5, profs.delrad[:,0]
    chi = np.sqrt((delinf - del_o)/(delinf - params.delad))
    Tcbpred = chi*params.To
    
    close(3)
    f , (ax1,ax2,ax3,ax4) = plt.subplots(4,figsize = (4.5,12),sharex = True, num = 3)   

    ax1.loglog(Matm/Me , profs.r[rcb_inds]/RBc, label = r'core')
    ax1.loglog(Matm/Me , profs.r[rcb_inds]/RB, label = r'total')
    ax2.semilogx(Matm/Me , Tcbpred, 'r', label = r'no self grav.')   
    ax2.semilogx(Matm/Me , profs.TK[rcb_inds], 'b', label = r'numeric')   
    ax3.loglog(Matm/Me , profs.P[rcb_inds]/barP)   
    ax4.loglog(Matm/Me , Mconv/Me, label = r'$M_\mathrm{conv}$')
    ax4.loglog(Matm/Me , Mrad/Me, label = r'$M_\mathrm{rad}$')
    ax4.loglog(Matm/Me , (Mconv + Mrad)/Me, label = r'$M_\mathrm{atm}$')
    
    ax1.legend(frameon = False , loc = 'upper center', title = r'Which $R_\mathrm{B}$')#, borderpad = 0, labelspacing = 0) 
    ax2.legend(frameon = False , loc = 'lower center')# , borderpad = 0, labelspacing = 0)    
    ax4.legend(frameon = False , loc = 'lower right')# , borderpad = 0, labelspacing = 0)    
    ax4.set_xlabel(r'$M_\mathrm{atm}\; [M_\oplus]$')
    
    ax1.set_ylabel(r'$R_\mathrm{CB} \; [R_\mathrm{B}]$')    
    ax2.set_ylabel(r'$T_\mathrm{CB}\;[\mathrm{K}]$')
    ax3.set_ylabel(r'$P_\mathrm{CB}\;[\mathrm{bar}]$')
    ax4.set_ylabel(r'$M \; [M_\oplus]$')
    #ax2.invert_xaxis()
    
    ax1.set_ylim(7e-2,2.5)
    ax2.set_ylim(47, 69)
    ax3.set_ylim(5e-8,2e-4)
    #ax4.set_ylim(ymin = 0.2)
    ax4.set_xlim(xmin = 0.5)

    plt.draw()
    plt.tight_layout()
    f.subplots_adjust(hspace=0)
    plt.draw()
    if savefig:
        plt.savefig(figfolder+'RCB_'+id+'.pdf')

if plotit[3]:
    Pcb = profs.P[rcb_inds]
    LoPo = 64*np.pi*G*mco*sigma*delad/3/params.kappa(Tcbpred) * Tcbpred**4
    Lpred = LoPo / Pcb
    
    pnum = 4 ; close(pnum)
    f , (ax1, ax2) = plt.subplots(ncols = 2,figsize = (7,3.8),sharey = True, num = pnum)

    ax1.loglog(Matm/Me, arr.L)
    ax2.loglog(profs.P[rcb_inds]/barP, Lpred, 'r', label = r'analytic')
    ax2.loglog(profs.P[rcb_inds]/barP, arr.L, 'b', label = r'numeric')
    ax2.legend(frameon = False, loc = 'lower left')
   
    ax1.set_xlabel(r'$M_\mathrm{atm}\; [M_\oplus]$')
    ax1.set_ylabel(r'$L_\mathrm{const} \; [\mathrm{erg\;s^{-1}}]$')
    ax2.set_xlabel(r'$P_\mathrm{CB} \; [\mathrm{bar}]$')
    
    ax1.set_ylim(2e23,4e26)
    ax1.set_xlim(xmin = 0.5)
    ax2.set_xlim(3e-8,3e-4)
    plt.draw()
    plt.tight_layout()
    f.subplots_adjust(wspace=0)
    plt.draw()
    if savefig:
        plt.savefig(figfolder+'LM_LPcb'+id+'.pdf')
